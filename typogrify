#!/bin/bash
usage(){
	fmt <<EOF
DESCRIPTION
	Apply some scriptable typography rules from the Standard Ebooks typography manual to a Standard Ebook source directory.

USAGE
	typogrify [-v,--verbose] [-nq,--no-quotes] DIRECTORY [DIRECTORY...]
		DIRECTORY is the source directory, which must contain DIRECTORY/src/.
		If called with the --no-quotes option, don't convert to smart quotes before doing other adjustments.
EOF
	exit
}
die(){ printf "Error: ${1}\n" 1>&2; exit 1; }
require(){ command -v $1 > /dev/null 2>&1 || { suggestion=""; if [ ! -z "$2" ]; then suggestion=" $2"; fi; die "$1 is not installed.${suggestion}"; } }
if [ $# -eq 1 ]; then if [ "$1" = "--help" -o "$1" = "-h" ]; then usage; fi fi
#End boilerplate

if [ $# -eq 0 ]; then
	usage
fi

# This script relies on readers implementing the Unicode line-break algorithm, with some small modifications.
# The algorithm is here: http://www.unicode.org/reports/tr14/#Dictionary
# UAX #14 is not very well written and is often unclear for beginners.  Table 2 is helpful. Additional enlightenment might be found here: https://www.cs.tut.fi/~jkorpela/unicode/linebr.html
# You can find the line break class of arbitrary Unicode characters here: http://unicode.org/cldr/utility/character.jsp
# Notes:
# -Quotation marks and thin/hair spaces shouldn't break according to the standard.  They are QU x BA.
# -Likewise ellipses and thin/hair spaces also shouldn't break: IN x BA
# - <a-z0-9,quote>[NB]<hairsp>[NB]<ellip>[NB]<hairsp>[NB]<.,!,?>
# - <a-z0-9,quote>[NB]<ellip>[NB]<period>
# Standard Ebooks exceptions:
# -Don't break before an em-dash or double-em-dash
# -Don't break before or after an en-dash
# -Don't break after some abbreviations (Mr., Mrs., etc; see regex below for full list)

require "recode" "Try: apt-get install recode"
require "xml2asc" "Try: apt-get install html-xml-utils"

scriptDir="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
smartypantsPath="${scriptDir}/smartypants.pl"
type="file"
verbose="false"
runSmartypants="true"
dirs=""

#Some convenience aliases
wj="\xE2\x81\xA0" #word joiner, U+2060
hairsp="\xE2\x80\x8A" #thin space, U+2009
nbsp=" " #no-break space, U+00A0

while [ $# -gt 0 ]
do
	case $1 in
		-v|--verbose)
			verbose="true"
		;;
		-nq|--no-quotes)
			runSmartypants="false"
		;;
		*)
			dirs=$(printf "%s\n%s" "${dirs}" "$1")
		;;
	esac
	shift
done

if [ "${verbose}" = "true" ]; then
	if [ "${runSmartypants}" != "true" ]; then
		printf "Skipping smart quotes ...\n"
	fi
fi

printf "%s\n" "${dirs}" | while IFS= read -r i;
do
	if [ "${i}" = "" ]; then
		continue
	fi

	srcDir="$(realpath "${i%/}")"

	if [ ! -d "${srcDir}/src" ]; then
		die "${srcDir} doesn't look like a Standard Ebook source directory."
	fi

	if [ "${verbose}" = "true" ]; then
		printf "Typogrifying %s ...\n" "${srcDir}"
	fi

	for file in $(find "${srcDir}" -name "*htm*")
	do
		#Skip symlinked files
		if [ -h "${file}" ]; then
			if [ "${verbose}" = "true" ]; then
				printf "\t%s is a symlink, skipping ... OK\n" "${file}"
			fi
			continue
		fi

		if [ "${verbose}" = "true" ]; then
			printf "\tTypogrifying %s ..." "${file}"
		fi

		#Some Gutenberg works have a weird single quote style: `this is a quote'.  Clean that up here before running Smartypants.
		sed --in-place --regexp-extended "s/\`/\'/g" "${file}"

		#Prettify quotes
		if [ "${runSmartypants}" = "true" ]; then
			"${smartypantsPath}" "${file}" | xml2asc | recode HTML | sed "s/&/&amp;/g" > "${file}.tmp";
			mv "${file}.tmp" "${file}"
		fi


		sed --in-place --regexp-extended "
		#Replace sequential em dashes with the two or three em dash character
		s/———/⸻/ig
		s/——/⸺/ig

		#Smartypants doesn't do well on em dashes followed by open quotes. Fix that here
		s/—”([a-z])/—“\1/ig
		s/—’([a-z])/—‘\1/ig

		#Remove spaces between en and em dashes
		#Note that we match at least one character before the dashes, so that we don't catch start-of-line em dashes like in poetry.
		#Sed doesn't seem to think tabs are whitespace?
		s/([^[:space:]	])\s*([–—])\s*/\1\2/ig

		#First, remove stray word joiners
		s/${wj}//ig

		#Some older texts use the ,— construct; remove that archaichism
		s/,—/—/ig

		#Em dashes and two-em-dashes can be broken before, so add a word joiner between letters/punctuation and the following em dash
		s/([^[:space:]${wj}])([—⸻])/\1${wj}\2/ig

		#Add a word joiner on both sides of en dashes
		s/${wj}?–${wj}?/${wj}–${wj}/ig

		#Remove word joiners from following opening tags--they're usually never correct
		s/<([a-z]+)([^>]*?)>${wj}/<\1\2>/ig

		#Finally fix some other mistakes
		s/⁠—-/⁠—/ig

		#Replace Mr., Mrs., and other abbreviations, and include a non-breaking space
		s/([^a-z]+)Mr(\.?)\s+/\1<abbr>Mr.<\/abbr>${nbsp}/g
		s/([^a-z]+)Mrs(\.?)\s+/\1<abbr>Mrs.<\/abbr>${nbsp}/g
		s/([^a-z]+)Ms(\.?)\s+/\1<abbr>Ms.<\/abbr>${nbsp}/g
		s/([^a-z]+)Dr(\.?)\s+/\1<abbr>Dr.<\/abbr>${nbsp}/g
		s/([^a-z]+)Dr(\.?)\s+/\1<abbr>Prof.<\/abbr>${nbsp}/g
		s/([^a-z]+)Dr(\.?)\s+/\1<abbr>Lieut.<\/abbr>${nbsp}/g
		s/([^a-z]+)Fr(\.?)\s+/\1<abbr>Fr.<\/abbr>${nbsp}/g
		s/([^a-z]+)Lt(\.?)\s+/\1<abbr>Lt.<\/abbr>${nbsp}/g
		s/([^a-z]+)Capt(\.?)\s+/\1<abbr>Capt.<\/abbr>${nbsp}/g
		s/([^a-z]+)Pvt(\.?)\s+/\1<abbr>Pvt.<\/abbr>${nbsp}/g
		s/([^a-z]+)Esq([^a-z\.])/\1<abbr>Esq.<\/abbr>\2/g
		s/([^a-z]+)Mt(\.?)\s+/\1<abbr>Mt.<\/abbr>${nbsp}/g
		s/([^a-z]+)MM(\.?)(\s+)/\1<abbr xml:lang=\"fr\">MM.<\/abbr>\3/g
		s/([^a-z]+)Mme(\.?)(\s+)/\1<abbr xml:lang=\"fr\">Mme.<\/abbr>\3/g
		s/([^a-z]+)Mmes(\.?)(\s+)/\1<abbr xml:lang=\"fr\">Mmes.<\/abbr>\3/g
		s/([^a-z]+)Mlle(\.?)(\s+)/\1<abbr xml:lang=\"fr\">Mlle.<\/abbr>\3/g
		s/([^a-z]+)Mlles(\.?)(\s+)/\1<abbr xml:lang=\"fr\">Mlles.<\/abbr>\3/g
		s/(\b)No\.(\s+[0-9]+)/\1<abbr>No.<\/abbr>\2/g

		#Sometimes the above abbreviations might get caught up in an image's alt tag, so remove the <abbr> tag from those cases.
		#The funny construction of this sed command makes it recursive, since we may have multiple <abbr>s embedded in a tag.
		:loop
		s|alt=\"([^\"]*?)<\/?abbr>|alt=\"\1|g
		t loop

		:loop
		s|<title>([^<]*?)<\/?abbr>|<title>\1|g
		t loop

		#A note on spacing:
		#					ibooks	kindle (mobi7)
		#thin space U+2009:			yes	yes
		#word joiner U+2060:			no	yes
		#zero-width no-break space U+FEFF:	yes	yes
		#narrow no-break space U+202F:		no	yes
		#punctuation space U+2008:		yes	yes

		#Fix common abbreviatons
		s/(\s)‘a’(\s)/\1’a’\2/ig

		#Years
		s/‘([0-9]+[^a-zA-Z0-9’])/’\1/ig

		s/‘([Mm]idst|[Gg]ainst|[Nn]eath|[Ee]m|[Tt]is|[Tt]was|[Tt]wixt|[Tt]were|[Tt]ween)(\b)/’\1\2/g

		#House style: remove spacing from common Latinisms
		s/i\.\s+e\./i.e./g
		s/e\.\s+g\./e.g./g

		#WARNING! This and below can remove the ending period of a sentence, if AD or BC is the last word!  We need interactive S&R for this
		s/([\d[:space:]])A\.\s+D\./\1<abbr class=\"era\">AD/g
		s/B\.\s+C\./<abbr class=\"era\">BC/g

		#Put spacing next to close quotes
		s/“[[:space:]${nbsp}]*‘/“${hairsp}‘/ig
		s/’[[:space:]${nbsp}]*”/’${hairsp}”/ig
		s/“[[:space:]${nbsp}]*’/“${hairsp}’/ig
		s/‘[[:space:]${nbsp}]*“/‘${hairsp}“/ig

		#We require a non-letter char at the end, otherwise we might match a contraction: “Hello,” ’e said.
		s/”[[:space:]${nbsp}]*’([^a-zA-Z])/”${hairsp}’\1/ig

		#Fix ellipses spacing
		s/\s*\.\s*\.\s*\.\s*/…/ig
		s/\s?…\s?\./.${hairsp}…/ig
		s/([a-zA-Z])\s?…/\1${hairsp}…/ig
		s/…[[:space:]${nbsp}]+([\)”’])/…\1/ig
		s/([\(“‘])[[:space:]${nbsp}]+…/\1…/ig
		s/…\s?([\!\?\.\;])/…${hairsp}\1/ig
		s/([\!\?\.\;”’])\s?…/\1${hairsp}…/ig
		s/\,\s?…/,${hairsp}…/ig

		#Add non-breaking spaces between amounts with an abbreviated unit.  E.g. 8 oz., 10 lbs.
		s/([0-9])\s([a-z]{1,3}\.)/\1${nbsp}\2/ig

		#Fix some spelling archaisms
		s/([Nn])aïve/\1aive/g
		s/([Nn])a[ïi]vet[ée]/\1aivete/g
		s/&amp;c\./<abbr>etc.<\/abbr>/g
		s/([Pp])rotege/\1rotégé/g

		#Fractions
		s/1\/4/¼/g
		s/1\/2/½/g
		s/3\/4/¾/g
		s/1\/3/⅓/g
		s/2\/3/⅔/g
		s/1\/5/⅕/g
		s/2\/5/⅖/g
		s/3\/5/⅗/g
		s/4\/5/⅘/g
		s/1\/6/⅙/g
		s/5\/6/⅚/g
		s/1\/8/⅛/g
		s/3\/8/⅜/g
		s/5\/8/⅝/g
		s/7\/8/⅞/g
		#Remove spaces between whole numbers and fractions
		s/([0-9,]+)\s+([¼½¾⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞])/\1\2/g

		" "${file}"

		perl -pi -e "s/(?<!\<abbr\>)Ph(\.?)D(\.?)/\<abbr class=\"degree\"\>PhD\<\/abbr\>/g;" "${file}"
		perl -pi -e "s/(?<!\<abbr\>)P\.\s*S\./\<abbr\>P.S.\<\/abbr\>/g;" "${file}"
		perl -pi -e "s/(?<!\<abbr\>)Co\./\<abbr\>Co.\<\/abbr\>/g;" "${file}"
		perl -pi -e "s/(?<!\<abbr\>)Inc\./\<abbr\>Inc.\<\/abbr\>/g;" "${file}"
		perl -pi -e "s/(?<!\<abbr\>)St\./\<abbr\>St.\<\/abbr\>/g;" "${file}"
		perl -pi -e "s/(?<!\<abbr\>)Messrs\./\<abbr xml:lang=\"fr\"\>Messrs.\<\/abbr\>/g;" "${file}"
		perl -pi -e "s/(?<!\<abbr\>)Messers\./\<abbr xml:lang=\"fr\"\>Messers.\<\/abbr\>/g;" "${file}"
		perl -pi -e "s/(?<!\<abbr\>)Prof\./\<abbr\>Prof.\<\/abbr\>/g;" "${file}"

		#Get Roman numerals >= 2 characters
		perl -pi -e "s/(?<!\<span epub\:type=\"z3998\:roman\"\>)(\b)([ixv]{2,})(\b)/\1\<span epub:type=\"z3998:roman\"\>\2\<\/span\>\3/ig;" "${file}"

		#Get Roman numerals that are X or V and single characters.  We can't do I for obvious reasons.
		perl -pi -e "s/(?<!\<span epub\:type=\"z3998\:roman\"\>)(\b)([vx])(\b)/\1\<span epub:type=\"z3998:roman\"\>\2\<\/span\>\3/ig;" "${file}"

		#Add <abbr class="name"> tag around initials: [A-Z]\.\s*([A-Z]\.\s*)+

		#Small caps AM and PM; thin space before Arabic numbers, but not if spelled out.  3&nbsp;<span class="time">a.m.</span>, one <span class="time">a.m.</span>

		#Search coordinates: ([0-9])+’/\1′ and ([0-9])+”/\1″

		#Search for em-dashes that were not closed correctly by smartypants: —[’”][^<\s]

		#Search for en-dash candidates: /([0-9]+)[\-—]([0-9]+)/\1–\2/sig

		#Surround ampersands in proper names with nbsp: hawkins & harker [a-zA-Z]\.?\s*&amp;\s*[a-zA-Z]

		#Text in all caps should be converted to correct case, surrounded by <b> styled for small caps: /[A-Z]{3,}/

		#Temperature: use unicode minus sign, not hyphen; small caps F and C:  /\-\d+\b/

		#Measurements: A x B x C should be A × B × C: /\sx\s/

		#Search common abbreviations: M., etc., &c., i.e., e.g.

		if [ "${verbose}" = "true" ]; then
			printf " OK\n"
		fi
	done
done
