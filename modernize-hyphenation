#!/bin/bash
usage(){
	fmt <<EOF
DESCRIPTION
	Replace words that may be archaically compounded with a dash to a more modern spelling.  For example, replace "ash-tray" with "ashtray".
	
	The word list used is generated from the "american-english-large" and "british-english-large" files provided by Debian's wamerican-large-7.1-1 and wbritish-large-7.1-1 packages, respectively.  The word list is generated by: `cat american-english-large british-english-large | sort -u`, plus some editorial removals.  This word list is large enough to be useful, but not so large that it introduces strange or rare compound words like Grant Ward's Moby word list or Debian's w(american|british)-english-(huge|insane) do.
	
	Note that the word list used is sometimes aggressive in removing dashes and isn't always correct.  If a changed word sounds strange or can be confused for a different word ("un-ionized" and "unionized"), double check the context and against a dictionary before accepting the change.

USAGE
	modernize-hyphenation [-v,--verbose] DIRECTORY [DIRECTORY...]
		DIRECTORY is the source directory, which must contain DIRECTORY/src/.
EOF
	exit
}
die(){ printf "Error: ${1}\n" 1>&2; exit 1; }
require(){ command -v $1 > /dev/null 2>&1 || { suggestion=""; if [ ! -z "$2" ]; then suggestion=" $2"; fi; die "$1 is not installed.${suggestion}"; } }
if [ $# -eq 1 ]; then if [ "$1" = "--help" -o "$1" = "-h" ]; then usage; fi fi
#End boilerplate

if [ $# -eq 0 ]; then
	usage
fi

scriptDir="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
dictPath="${scriptDir}/words"

while [ $# -gt 0 ]
do
	case $1 in
		-v|--verbose)
			verbose="true"
		;;
		*)
			dirs=$(printf "%s\n%s" "${dirs}" "$1")
		;;
	esac
	shift
done

printf "%s\n" "${dirs}" | while IFS= read -r i;
do
	if [ "${i}" = "" ]; then
		continue
	fi
	
	srcDir="$(realpath "${i%/}")"
	
	if [ ! -d "${srcDir}/src" ]; then
		die "${srcDir} doesn't look like a Standard Ebooks ebook source directory."
	fi

	if [ "${verbose}" = "true" ]; then
		printf "Replacing in %s ...\n" "${srcDir}"
	fi

	for file in $(find "${srcDir}" -name "*htm*")
	do
		if [ "${verbose}" = "true" ]; then
			printf "\tReplacing in %s ...\n" "${file}"
		fi
		
		for word in $(grep --only-matching --ignore-case --extended-regexp "\b[[:alpha:]]+\-[[:alpha:]]+\b" "${file}" | uniq | sed --regexp-extended "/en-(US|GB)/d")
		do
			newWord=$(printf "%s" "${word}" | sed "s/\-//g" | tr "[:upper:]" "[:lower:]")
			found="false"
			
			if grep --quiet "^${newWord}$" "${dictPath}"; then
				found="true"
			fi
			
			if [ "${found}" = "true" ]; then
				lhs=$(echo "${word}" | grep --only-matching --ignore-case --extended-regexp "[[:alpha:]]+\-" | sed "s/\-//")
				rhs=$(echo "${word}" | grep --only-matching --ignore-case --extended-regexp "\-[[:alpha:]]+" | sed "s/\-//")
				if [ "${verbose}" = "true" ]; then
					printf "\t\tReplacing %s with %s ... OK\n" "${word}" "${lhs}${rhs}"
				fi
				sed --in-place "s/${lhs}\-${rhs}/${lhs}${rhs}/g" "${file}"
				
				if [ "${word}" = "non-fiction" ]; then
					sed --in-place "s/z3998:nonfiction/z3998:non-fiction/g" "${file}"
				fi
			fi
		done
	done
done
